import pandas as pdimport numpy as npimport osimport networkx as nxfrom sklearn.preprocessing import MinMaxScalera = 2.3b = 4.1n = 50list_reg_path = "mols/list_reg"mols_dir = "mols/mols"molecule_info = pd.read_csv(list_reg_path, sep='\s+', header=0, usecols=[0, 1])molecule_info.columns = ['Name', 'Tg']def read_xyz_to_graph(file_path, cutoff):    with open(file_path, 'r') as f:        lines = f.readlines()     num_atoms = int(lines[0].strip())    atoms = []    for line in lines[2:2 + num_atoms]:        parts = line.split()        atoms.append((parts[0], float(parts[1]), float(parts[2]), float(parts[3])))    adj_matrix = np.zeros((num_atoms, num_atoms))    for i in range(num_atoms):        for j in range(i + 1, num_atoms):            dist = np.linalg.norm(np.array(atoms[i][1:]) - np.array(atoms[j][1:]))            if dist <= cutoff:                adj_matrix[i, j] = 1                adj_matrix[j, i] = 1    np.fill_diagonal(adj_matrix, 0)    G = nx.from_numpy_array(adj_matrix)    for i, atom in enumerate(atoms):        G.nodes[i]['element'] = atom[0]        G.nodes[i]['x'] = atom[1]        G.nodes[i]['y'] = atom[2]        G.nodes[i]['z'] = atom[3]    return Gdef calculate_graph_features(G):    if G is None or len(G) == 0:        return {            'largest_eigenvalue': 0,            'smallest_eigenvalue': 0,            'second_largest_eigenvalue': 0,            'second_smallest_eigenvalue': 0        }    L = nx.laplacian_matrix(G).todense()    eigenvalues = np.linalg.eigvals(L)    eigenvalues_real = np.real(eigenvalues)    largest_eigenvalue = np.max(eigenvalues_real)    second_largest_eigenvalue = sorted(eigenvalues_real, reverse=True)[1]    smallest_eigenvalue = np.min(eigenvalues_real)    second_smallest_eigenvalue = sorted(eigenvalues_real)[1]    return {        'largest_eigenvalue': largest_eigenvalue,        'smallest_eigenvalue': smallest_eigenvalue,        'second_largest_eigenvalue': second_largest_eigenvalue,        'second_smallest_eigenvalue': second_smallest_eigenvalue    }def calculate_all_features(a, b, n):    all_features = []    r_values = np.linspace(a, b, n)    for idx, row in molecule_info.iterrows():        molecule_name = row['Name']        molecule_tg = row['Tg']        xyz_path = os.path.join(mols_dir, f"{molecule_name}.xyz")        if not os.path.exists(xyz_path):            continue        molecule_features = []        for r in r_values:            G = read_xyz_to_graph(xyz_path, r)            graph_features = calculate_graph_features(G)            feature_row_graph = list(graph_features.values())            molecule_features.extend(feature_row_graph)        molecule_features.append(molecule_tg)        all_features.append(molecule_features)    return all_features, r_valuesall_features, r_values = calculate_all_features(a, b, n)global_feature_columns = list(calculate_graph_features(None).keys())feature_columns = []for r in r_values:    for col in global_feature_columns:        feature_columns.append(f"{col}_r{r:.2f}")feature_columns.append("Tg")features_df = pd.DataFrame(all_features, columns=feature_columns)scaler = MinMaxScaler()features_normalized = scaler.fit_transform(features_df.iloc[:, :])features_normalized_df = pd.DataFrame(features_normalized, columns=feature_columns)output_path = "dataset/reg_laplace_" + str(int(n)) + ".csv"features_normalized_df.to_csv(output_path, index=False, header=False)print(f"Done. {output_path}.")